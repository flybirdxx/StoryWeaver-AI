# **StoryWeaver AI 项目代码审查与优化建议**

## **1\. 核心架构与数据持久化 (Critical)**

目前项目使用 内存存储 (In-Memory Storage) 来保存数据（见 server/routes/project.js 和 character.js 中的 let projects \= \[\]）。  
风险： 一旦服务器重启（或进程崩溃），所有用户创建的项目、角色和生成的图像记录都会丢失。

### **优化方案：引入轻量级数据库**

建议从内存数组迁移到本地数据库。对于此类单机/个人项目，**SQLite** 是最佳选择（无需安装额外数据库服务，文件即数据库）。

**推荐工具：** better-sqlite3 或 sequelize (配合 sqlite 驱动)。

**代码示例 (使用 better-sqlite3):**

1. 安装: npm install better-sqlite3  
2. 新建 server/db.js:

const Database \= require('better-sqlite3');  
const path \= require('path');

// 数据库文件保存在项目根目录  
const db \= new Database(path.join(\_\_zh-CN\_, '../../storyweaver.db'), { verbose: console.log });

// 初始化表结构  
db.exec(\`  
  CREATE TABLE IF NOTXs projects (  
    id TEXT PRIMARY KEY,  
    name TEXT NOT NULL,  
    tags TEXT,  
    data TEXT, \-- 存储完整的 JSON 对象  
    created\_at DATETIME DEFAULT CURRENT\_TIMESTAMP,  
    updated\_at DATETIME DEFAULT CURRENT\_TIMESTAMP  
  );

  CREATE TABLE IF NOT EXISTS characters (  
    id TEXT PRIMARY KEY,  
    name TEXT NOT NULL,  
    data TEXT,  
    created\_at DATETIME DEFAULT CURRENT\_TIMESTAMP  
  );  
\`);

module.exports \= db;

3. 改造 server/routes/project.js:

const db \= require('../db');

// 获取所有项目  
router.get('/', (req, res) \=\> {  
  const rows \= db.prepare('SELECT \* FROM projects ORDER BY updated\_at DESC').all();  
  const projects \= rows.map(row \=\> ({  
    ...JSON.parse(row.data),  
    id: row.id // 确保 ID 一致  
  }));  
  res.json({ success: true, data: projects });  
});

// 保存项目  
router.post('/', (req, res) \=\> {  
  const newProject \= { ...req.body, id: uuidv4() }; // 你的原始逻辑  
    
  const stmt \= db.prepare('INSERT INTO projects (id, name, tags, data) VALUES (?, ?, ?, ?)');  
  stmt.run(newProject.id, newProject.name, JSON.stringify(newProject.tags), JSON.stringify(newProject));  
    
  res.json({ success: true, data: newProject });  
});

## **2\. 安全性增强 (Security)**

### **A. CORS 配置过于宽松**

目前 server/index.js 中使用了 origin: '\*'：

app.use(cors({  
  origin: '\*', // ⚠️ 允许任何网站访问你的 API  
  // ...  
}));

风险： 如果你部署到公网，任何恶意网站都可以调用你的 API 消耗你的 Token。  
建议： 限制为前端域名。  
const allowedOrigins \= \['http://localhost:8080', '\[http://127.0.0.1:8080\](http://127.0.0.1:8080)'\];  
app.use(cors({  
  origin: function (origin, callback) {  
    if (\!origin || allowedOrigins.indexOf(origin) \!== \-1) {  
      callback(null, true);  
    } else {  
      callback(new Error('Not allowed by CORS'));  
    }  
  }  
}));

### **B. API Key 的传输方式**

目前 API Key 有时通过 Body 传输，有时通过 Headers 传输（流式请求中使用了 X-API-Key，普通请求在 body 中）。  
建议： 统一使用 Authorization Header (Bearer Token) 或自定义 Header X-API-Key，避免将敏感信息放在 POST Body 中（Body 可能会被日志记录）。

## **3\. 前端代码结构与维护 (Frontend Architecture)**

目前前端是纯原生 JS (vanilla JS) \+ 字符串模板拼接 (innerHTML)。  
现状：

* 代码分散在 app.js, dashboard.js, storyboard.js 中。  
* DOM 操作频繁（如 document.getElementById），容易导致状态不同步。  
* storyboard.js 中的 render() 方法在每次更新时都暴力重绘整个列表，性能较差且丢失滚动位置。

### **优化建议：**

虽然重构成本较高，但如果要长期维护，建议引入 **Vue.js (CDN版)** 或 **Alpine.js**。它们非常轻量，不需要复杂的构建流程 (Webpack/Vite)，就能极大简化状态管理。

**Alpine.js 示例 (简化 storyboard.js 的渲染逻辑):**

\<\!-- 在 HTML 中引入 Alpine \--\>  
\<script defer src="\[https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js\](https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js)"\>\</script\>

\<\!-- 使用 x-data 绑定数据，x-for 循环渲染 \--\>  
\<div x-data="storyboardApp()" class="lg:col-span-5 ..."\>  
    \<template x-for="panel in panels" :key="panel.id"\>  
        \<div @click="selectPanel(panel.id)"   
             :class="selectedId \=== panel.id ? 'bg-orange-50 border-orange-500' : 'hover:bg-stone-50'"  
             class="flex gap-3 px-3 py-3 border-l-4 cursor-pointer transition-colors"\>  
               
             \<\!-- 图片展示 \--\>  
             \<div class="w-16 h-16 bg-stone-100"\>  
                 \<img x-show="panel.imageUrl" :src="panel.imageUrl" class="w-full h-full object-cover"\>  
                 \<div x-show="\!panel.imageUrl" class="text-xs text-stone-400"\>生成中...\</div\>  
             \</div\>  
               
             \<\!-- 内容 \--\>  
             \<div class="flex-1"\>  
                 \<span x-text="\`\#${panel.id} ${panel.type}\`" class="text-\[10px\] font-mono"\>\</span\>  
                 \<p x-text="panel.prompt" class="text-xs truncate"\>\</p\>  
             \</div\>  
        \</div\>  
    \</template\>  
\</div\>

\<script\>  
function storyboardApp() {  
    return {  
        panels: \[\], // 从后端加载  
        selectedId: null,  
        selectPanel(id) { this.selectedId \= id; },  
        // ...其他逻辑  
    }  
}  
\</script\>

## **4\. 图像生成与流式处理优化 (Performance)**

在 server/routes/image.js 中，你已经实现了很好的 SSE (Server-Sent Events) 流式处理。

### **优化点：并发控制与错误重试**

目前代码中：

const batchSize \= 3;  
// ...  
const batchPromises \= batch.map(panel \=\> processPanel(panel));  
await Promise.all(batchPromises);

Gemini API 有严格的速率限制（Rate Limits，特别是免费层或预览版）。简单的 Promise.all 可能会导致 429 (Too Many Requests) 错误。

**建议：** 引入**请求队列 (Queue)** 或使用 p-limit 库来更精细地控制并发，并添加指数退避 (Exponential Backoff) 重试机制。

// 简单的重试逻辑封装  
async function generateWithRetry(fn, retries \= 3\) {  
  for (let i \= 0; i \< retries; i++) {  
    try {  
      return await fn();  
    } catch (error) {  
      if (error.status \=== 429 && i \< retries \- 1\) {  
        const delay \= Math.pow(2, i) \* 1000; // 1s, 2s, 4s  
        console.log(\`Rate limited. Retrying in ${delay}ms...\`);  
        await new Promise(r \=\> setTimeout(r, delay));  
      } else {  
        throw error;  
      }  
    }  
  }  
}

## **5\. UI/UX 细节优化**

1. **Markdown 渲染:**  
   * **问题:** 剧本分析结果（scriptStudio.js）直接使用 innerText 显示 JSON 或简单文本。  
   * **建议:** 引入 marked 库，支持剧本的 Markdown 格式预览，让阅读体验更好。  
2. **图片加载占位符:**  
   * **问题:** 目前如果图片生成失败或正在加载，UI 只是简单的文字提示。  
   * **建议:** 使用骨架屏 (Skeleton Loader) 动画效果 (Tailwind 的 animate-pulse 类) 来提升感知体验。  
3. **移动端适配:**  
   * **问题:** storyboard 的布局在移动端是堆叠的，但操作按钮（生成图片）可能占据屏幕太多空间。  
   * **建议:** 在移动端将工具栏折叠进一个 "Action Sheet" 或底部浮动按钮 (FAB)。

## **6\. 代码规范小建议**

* **server/services/geminiService.js**:  
  * 目前同时使用了 SDK (@google/generative-ai) 和 node-fetch 直接调 REST API。  
  * **建议:** 既然 gemini-3-pro-image-preview 目前只能通过 REST API 访问（SDK支持可能滞后），建议将 HTTP 请求逻辑封装一个私有的 helper 方法，统一处理 Header、Auth 和 Error Parsing，减少重复代码。  
* **环境变量管理**:  
  * server/utils/checkEnv.js 做得很好。  
  * 建议增加 PROJECT\_DIR 或 DB\_PATH 等配置，方便部署时修改存储路径。

### **总结推荐实施路线图**

1. **Phase 1 (稳定性):** 引入 better-sqlite3 实现数据持久化。这是目前最大的痛点。  
2. **Phase 2 (健壮性):** 在后端图像生成服务中添加 429 错误自动重试机制。  
3. **Phase 3 (体验):** 优化前端状态管理（考虑 Alpine.js）和 API Key 的安全传输。

\#\#\# 总结  
您的项目完成度很高，核心的 AI 编排逻辑（剧本-\>分镜-\>图像）非常清晰。目前最大的短板在于\*\*数据无法保存\*\*和\*\*前端原生代码的维护复杂度\*\*。实施上述第 1 点（引入 SQLite）将立即使项目从一个“演示 Demo”转变为一个可用的“工具”。  
